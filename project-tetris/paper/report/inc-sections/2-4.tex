\textbf{2.3}에서 설명한 이론과 실제 코드를 비교하고 분석한다.

\subsubsection{테트리스 게임 클라이언트}
테트리스 게임 클라이언트는 다음과 같은 파일로 구성된다. 

\begin{tabularx}{\linewidth}{l|X}
    파일 이름 & 기능 \\
    \hline
    tetris.c, tetris.h & 핵심적인 테트리스 게임 로직 \\
    \hline
    ordered_list.c, ordered_list.h & 랭킹 정보를 담는 노드와 정렬된 리스트의 RB 트리 구현 및 관련된 알고리즘 \\
    decision_tree.c, decision_tree.h & 가능한 미래 상태들을 저장하는 노드와 결정 트리의 구현 및 관련된 알고리즘 \\
    queue.c, queue.h & 가능한 조각 놓는 위치를 판정하기 위해 BFS에서 사용하는 큐와 가능한 상태를 나타내는 3-tuple의 구현 및 관련된 알고리즘 \\
    \hline
    makefile & 프로젝트의 빌드 정보 \\
\end{tabularx}

\subsubsection{테트리스 게임 클라이언트 1주차} 1주차에 구현된 함수들은 다음과 같다.

\mintinline[breaklines]{c}{int CheckToMove(char f[HEIGHT][WIDTH], int currentBlock, int blockRotate, int blockY, int blockX)}
: 주어진 위치에 블록을 놓을 수 있는지 확인한다. 구현된 코드는 설계한 의사 코드를 그대로 구현하였다.

\mintinline[breaklines]{c}{void DrawChange(char f[HEIGHT][WIDTH], int command, int currentBlock, int blockRotate, int blockY, int blockX)}
: 필드에서 바뀐 부분을 화면에 업데이트한다. 구현된 코드는 설계한 의사 코드를 그대로 구현하였다.

\mintinline[breaklines]{c}{void BlockDown(int sig)}
: 블럭이 일정 시간마다 내려갈 수 있도록 한다.

3주차의 자동 플레이에 대응하기 위해 \texttt{flag_autoplay}가 설정되어 있을 경우 현재 블록을 무조건 추천 블록 위치에 가져다 놓는 루틴이 추가되어 있다(줄 425--429).
또한 추천 알고리즘을 강도 있게 훈련하기 위해 디버그 옵션 \texttt{DEBUG_GARBAGE_MODE}이 설정되어 있으면 매 15개의 블록을 떨어뜨릴 때마다
한 칸만 비어 있는 쓰레기 열을 밑에서 추가하도록 수정하였다(줄 443--457). 

다음 블록의 개수가 2개 이상으로 설정되어 있더라도 그만큼 새로운 블록을 생성하도록 수정되었으며(줄 459--462), 현재 블록이 고정되는 순간 다음 블록에 대한
추천 위치를 계산하도록 수정하였다(줄 470--471). 마지막으로 전술한 바와 같이 테트리스 추천 알고리즘의 목표는 4라인 클리어를 최대화하는 것이므로,
이를 현재 추천 알고리즘이 잘 수행하고 있는지 확인하기 위해 \texttt{DEBUG}가 설정되어 있으면 현재 게임에 대해 각 라인 클리어 별 빈도 수를
확인할 수 있는 통계를 표시하는 기능을 추가하였다(줄 476--501).

\mintinline[breaklines]{c}{int AddBlockToField(char f[HEIGHT][WIDTH], int currentBlock, int blockRotate, int blockY, int blockX)}
: 필드의 특정 위치에 블록을 고정시킨다. 인접한 칸 수에 비례해 계산된 점수를 반환한다. 구현된 코드는 설계한 의사 코드를 그대로 구현하였다.

\mintinline[breaklines]{c}{int DeleteLine(char f[HEIGHT][WIDTH])}
: 필드에서 완성된 줄이 있으면 지우고 점수를 계산해 반환한다.
\texttt{DEBUG}가 설정되어 있으면 지워진 줄 수에 대한 통계를 계산하기 위해 통계 값을 증가시키는 코드가
추가되었고(줄 550--555), 이외의 부분은 설계한 의사 코드를 그대로 구현하였다.

\mintinline[breaklines]{c}{int GhostY(int y, int x, int blockID, int blockRotate)}
: 주어진 위치에서 그림자의 $y$좌표를 계산한다. 구현된 코드는 설계한 의사 코드를 그대로 구현하였다.

\subsubsection{테트리스 게임 클라이언트 2주차} 2주차에 구현된 함수들은 이름으로 쿼리하는 부분을 제외하고
모두 의사 코드를 그대로 구현하였다.

이름으로 쿼리하는 부분은 따로 함수가 만들어지지 않았고, tetris.c의 줄 650--672에 구현되었다. 의사 코드에 추가해
\texttt{flag}를 플래그로 활용하여 검색한 결과가 없을 경우 검색 실패 메시지를 표시하도록 수정되었다.

\subsubsection{테트리스 게임 클라이언트 3주차} 3주차에 구현된 함수들은 다음과 같다.

\mintinline[breaklines]{c}{void decision_tree_node_quicksort(decision_tree_node *array, int start, int end)}
: 결정 트리 노드 배열을 정렬한다. 점수를 2-tuple로 관리하면서, 점수 비교를 위해 tuple의 두 값을 더해 비교하는 점이
이론과 달라졌다(줄 39--40, 43--44).

가능한 위치들을 찾는 함수는 따로 구현되지 않았고, tetris.c의 줄 17--19와 951--1010에 구현되었다.

\begin{wrapfigure}{l}{0.3\textwidth}
\OMINO{%
...........\\%
...........\\%
+---+.+-+..\\%
|X.X|.|T|..\\%
|...+-+.+-+\\%
|X.X|T.T|X|\\%
|.+-+-+.+.+\\%
|X|...|T|X|\\%
+-+...+-+-+\\%
}
\caption{회전 불가능한 T}
\label{fig:impossible}
\end{wrapfigure}

이론을 구체화해 $visit$ 여부를 체크하는 3차원 배열을 만들어 방문 여부를 체크할 수 있도록 했다. $visit$을 새로 만드는 것은 시간이 걸릴 것으로 예상해,
전역 변수로 두고 새로 탐색할 필요가 있을 때마다 \texttt{memset}으로 초기화하였다. 인접한 칸을 체크하는 부분은 \texttt{dx}, \texttt{dy} 배열을
만들어 \texttt{for} 루프로 쉽게 체크할 수 있도록 하였다.

이론에서 틀린 부분이 있었는데, Figure \ref{fig:impossible}의 경우 T 블록을 회전해 왼쪽 안으로 밀어넣는 것이 불가능하다. 이론에서는
이동과 회전을 동시에 고려해, 이런 상태에서 T 블록을 회전해 왼쪽 안으로 밀어넣는 수를 추천하는 상황이 발생했다. 이 오류는 이동과 회전을 따로 생각하게
코드를 수정하면서 해결되었다(줄 971--1009).

또한 회전 시 블록이 놓일 수 있는 위치를 판별하는 로직을 변경하였다(줄 1004--1008). 만약 회전을 했는데 필드에 놓일 수 없다면 회전된 상태는 판별하지
않는 것이 바람직하다.

이외에도 3-tuple을 사용하는 등 자료구조 상의 약간의 구체화가 있었으나 알고리즘 자체는 설계한 의사 코드에서 크게 변하지 않았다.

\mintinline[breaklines]{c}{decision_tree_node recommend_bfs(int level, decision_tree_node *parents, int parent_count)}
: 블록의 최적 추천 위치를 찾기 위해 너비 우선 탐색을 수행한다. 대부분이 의사 코드 그대로 구현되었으나, 구체화된 점들이 일부 존재한다.

\texttt{max_score}는 $\infty$가 아닌, 임의의 큰 수 987654321로 정의되었다. \texttt{childs}는 동적 배열로 정의되었다.
가능한 위치들을 찾는 함수는 구현하는 대신 \texttt{recommend_bfs} 함수 내부에 코드로 포함되었다. 또한 필드 점수가 2-tuple 구조를 사용하도록 하였는데,
\texttt{boardScore}와 \texttt{propagatedScore}를 따로 두어 \texttt{boardScore}의 경우 현재 노드에만 반영하지만
\texttt{propagatedScore}의 경우 자식 노드에 누적되도록 하였다. 이유는 후술한다.

\mintinline[breaklines]{c}{score_pair boardScore(char f[HEIGHT][WIDTH], int nextBlock, int rot, int blockY, int blockX)}
: 필드의 점수를 계산한다. 실제 구현은 다음과 같다. 휴리스틱을 계산하는 부분은 비슷한 루프를 한 루프로 묶은 구현 상의 차이(줄 832--866)를
제외하고는 의사 코드와 같다.

여기에서 가장 중요한 부분은 \texttt{boardScore}와 \texttt{propagatedScore}가 따로 계산된다는 점인데, \texttt{boardScore}는 현재 보드
상황에 매긴 점수인 반면 \texttt{propagatedScore}는 현재 동작에 매긴 점수이다.

만약 다음 블록 3개의 조합이 차례로 3줄, 4줄, 1줄을 지울 수 있는 경우와 차례로 1줄, 1줄, 2줄을 지울 수 있는 경우가 있다고 생각하자.
현재 동작에 대한 점수가 누적되지 않는다면 추천 알고리즘은 최종 노드에서 할 수 있는 최선의 선택인 차례로 1줄, 1줄, 2줄을 지우는 경우를 택할 것이다.
하지만 차례로 3줄, 4줄, 1줄을 지우는 경우가 더 효율적이다. 이런 상황을 방지하기 위해 누적되는 점수의 개념을 따로 도입했다.